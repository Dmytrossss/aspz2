# Лабораторна робота 2:

**Виконав: Гнилицький Дмитро**

**Група: ТВ-33**  

**Завдання**

**Завдання ЗАГАЛЬНЕ ДЛЯ ВСІХ**

1. Напишіть програму для визначення моменту, коли time_t

закінчиться.Дослідіть, які зміни відбуваються в залежності від 32- та

64-бітної архітектури. Дослідіть сегменти виконуваного файлу.

**Завдання 2.2.**

Розгляньте сегменти у виконуваному файлі.

1. Скомпілюйте програму &quot;hello world&quot;, запустіть ls -l для

виконуваного файлу, щоб отримати його загальний розмір, і

запустіть size, щоб отримати розміри сегментів всередині нього.

2. Додайте оголошення глобального масиву із 1000 int,

перекомпілюйте й повторіть вимірювання. Зверніть увагу на

відмінності.

3. Тепер додайте початкове значення в оголошення масиву

(пам’ятайте, що C не змушує вас вказувати значення для кожного

елемента масиву в ініціалізаторі). Це перемістить масив із сегмента

BSS у сегмент даних. Повторіть вимірювання. Зверніть увагу на

різницю.

4. Тепер додайте оголошення великого масиву в локальну функцію.

Оголосіть другий великий локальний масив з ініціалізатором.

Повторіть вимірювання. Дані розташовуються всередині функцій,

залишаючись у виконуваному файлі? Яка різниця, якщо масив

ініціалізований чи ні?

5. Які зміни відбуваються з розмірами файлів і сегментів, якщо ви

компілюєте для налагодження? Для максимальної оптимізації?

Проаналізуйте результати, щоб переконатися, що:

● сегмент даних зберігається у виконуваному файлі;

● сегмент BSS не зберігається у виконуваному файлі (за винятком

примітки щодо його вимог до розміру часу виконання);

● текстовий сегмент більшою мірою піддається перевіркам

оптимізації;

● на розмір файлу a.out впливає компіляція для налагодження, але не
сегменти.

**Завдання 2.4**

Ваше завдання – дослідити стек процесу або пригадати, як це робиться. Ви
можете:

● Автоматично за допомогою утиліти gstack.

● Вручну за допомогою налагоджувача GDB.

Користувачі Ubuntu можуть зіткнутися з проблемою: на момент написання

(Ubuntu 18.04) gstack, схоже, не був доступний (альтернативою може бути

pstack). Якщо gstack не працює, використовуйте другий метод – через

GDB, як показано нижче.

Спочатку подивіться на стек за допомогою gstack(1). Нижче наведений

приклад стека bash (аргументом команди є PID процесу):

$ gstack 14654

#0 0x00007f359ec7ee7a in waitpid () from /lib64/libc.so.6

#1 0x000056474b4b41d9 in waitchild.isra ()

#2 0x000056474b4b595d in wait_for ()

#3 0x000056474b4a5033 in execute_command_internal ()

#4 0x000056474b4a5c22 in execute_command ()

#5 0x000056474b48f252 in reader_loop ()

#6 0x000056474b48dd32 in main ()

$

Розбір стека:

● Номер кадру стека відображається ліворуч перед символом #.

● Кадр #0 – це найнижчий кадр. Читайте стек знизу вверх (тобто від

main() – кадр #6 – до waitpid() – кадр #0).

● Якщо процес багатопотоковий, gstack покаже стек кожного потоку

окремо.

Аналіз стека в режимі користувача через GDB

Щоб переглянути стек процесу вручну, використовуйте GDB,

приєднавшись до процесу.

Нижче наведена невелика тестова програма на C, що виконує кілька

вкладених викликів функцій. Граф викликів виглядає так:

main() --&gt; foo() --&gt; bar() --&gt; bar_is_now_closed() --&gt; pause()

Системний виклик pause() – це приклад блокуючого виклику. Він

переводить викликаючий процес у сплячий режим, очікуючи (або

блокуючи) сигнал. У цьому випадку процес блокується, поки не отримає

будь-який сигнал.

#include &lt;stdio.h&gt;

#include &lt;stdlib.h&gt;

#include &lt;unistd.h&gt;

#include &lt;sys/types.h&gt;

#define MSG &quot;In function %20s; &amp;localvar = %p\n&quot;

static void bar_is_now_closed(void) {

int localvar = 5;

printf(MSG, __FUNCTION__, &amp;localvar);

printf(&quot;\n Now blocking on pause()...\n&quot;);

pause();

}

static void bar(void) {

int localvar = 5;

printf(MSG, __FUNCTION__, &amp;localvar);

bar_is_now_closed();

}

static void foo(void) {

int localvar = 5;

printf(MSG, __FUNCTION__, &amp;localvar);

bar();

}

int main(int argc, char **argv) {

int localvar = 5;

printf(MSG, __FUNCTION__, &amp;localvar);

foo();

exit(EXIT_SUCCESS);

}

Тепер відкрийте GDB

У ньому підключіться (attach) до процесу (в наведеному прикладі PID =

24957) і дослідіть стек за допомогою команди backtrace (bt):

$ gdb --quiet

(gdb) attach 24957

Attaching to process 24957

Reading symbols from &lt;...&gt;/hspl/unit2/stacker...done.

Reading symbols from /lib64/libc.so.6...Reading symbols from

/usr/lib/debug/usr/lib64/libc-2.26.so.debug...done.

done.

Reading symbols from /lib64/ld-linux-x86-64.so.2...Reading symbols

...

(gdb) bt

...

Примітка: В Ubuntu, через питання безпеки, GDB не дозволяє

підключатися до довільного процесу. Це можна обійти, запустивши GDB

від імені користувача root.

Аналіз того ж процесу через gstack

$ gstack 24957

...

gstack — це, по суті, оболонковий скрипт (wrapper shell script), який

неінтерактивно викликає GDB і запускає команду backtrace, яку ви

щойно використали.

Завдання: Ознайомтеся з виводом gstack і порівняйте його з GDB.

## 1. Дослідження time_t та архітектурних відмінностей

### Код програми (`end_of_time.c`):
```c
#include <stdio.h>
#include <time.h>
#include <limits.h>

int main() {
    printf("Розмір time_t: %ld байт\n", sizeof(time_t));
    
    if (sizeof(time_t) == 4) {
        time_t max_time = INT_MAX;
        printf("32-бітний time_t закінчиться: %s", ctime(&max_time));
    } else {
        printf("64-бітний time_t закінчиться приблизно у 292,277,026,596 років\n");
    }
    
    return 0;
}
```

### Результати виконання:
```
64-бітна версія:
Розмір time_t: 8 байт
64-бітний time_t закінчиться приблизно у 292,277,026,596 років

32-бітна версія:
Розмір time_t: 4 байт
32-бітний time_t закінчиться: Tue Jan 19 05:14:07 2038
```

### Аналіз сегментів:
```
64-бітна версія:
  text   data   bss    dec     hex   filename
  1920    576    16   2512   0x9d0   end_of_time_64

32-бітна версія:
  text   data   bss    dec     hex   filename
  1748    288     8   2044   0x7fc   end_of_time_32
```

**Висновок:**  
Розмір типу `time_t` критично залежить від архітектури процесора. У 32-бітних системах існує "проблема 2038 року", коли time_t переповниться 19 січня 2038 року. У 64-бітних системах цей час становить понад 292 мільярди років, що практично невичерпно. Сегменти пам'яті між архітектурами відрізняються: 64-бітна версія має більший розмір text сегменту (1920 vs 1748 байт), що пов'язано з більшою довжиною інструкцій.

## 2. Дослідження сегментів пам'яті у виконуваних файлах

### 2.1 Базова програма "Hello World"
**Код (`hello_segments.c`):**
```c
#include <stdio.h>
int main() {
    printf("Hello, World!\n");
    return 0;
}
```

**Результати:**
```
Розмір файлу: 13736 байт
Сегменти:
  text   data   bss    dec     hex   filename
  1691    568    16   2275   0x8e3  hello_segments
```

### 2.2 Додавання неініціалізованого глобального масиву
**Код (`hello_segments_v2.c`):**
```c
#include <stdio.h>
int global_array[1000];
int main() {
    printf("Hello, World!\n");
    return 0;
}
```

**Результати:**
```
Розмір файлу: 13776 байт
Сегменти:
  text   data    bss    dec      hex   filename
  1691    568   4032   6291   0x1893  hello_segments_v2
```

### 2.3 Додавання ініціалізованого глобального масиву
**Код (`hello_segments_v3.c`):**
```c
#include <stdio.h>
int global_array[1000] = {1};
int main() {
    printf("Hello, World!\n");
    return 0;
}
```

**Результати:**
```
Розмір файлу: 17792 байт
Сегменти:
  text   data   bss    dec      hex   filename
  1691   4584    16   6291   0x1893  hello_segments_v3
```

### 2.4 Локальні масиви у функції
**Код (`hello_segments_v4.c`):**
```c
#include <stdio.h>
int main() {
    int local_array1[1000];
    int local_array2[1000] = {0};
    printf("Hello, World!\n");
    return 0;
}
```

**Результати:**
```
Розмір файлу: 13776 байт
Сегменти:
  text   data   bss    dec     hex   filename
  1723    568    16   2307   0x903  hello_segments_v4
```

### 2.5 Вплив оптимізації та налагодження
| Версія               | text | data | bss  | dec  | Розмір файлу | Оптимізація |
|----------------------|------|------|------|------|--------------|-------------|
| Базова               | 1691 | 568  | 16   | 2275 | 13736        | -O0         |
| Базова (оптим.)      | 1702 | 568  | 16   | 2286 | 13744        | -O2         |
| Базова (налагод.)    | 1691 | 568  | 16   | 2275 | 14336        | -g          |

### Аналіз результатів:
1. **BSS сегмент**: Неініціалізовані глобальні змінні (як у v2) збільшують BSS сегмент (4032 байти), але не впливають на розмір файлу (13776 байт vs 13736 у базовій версії). Це підтверджує, що BSS не зберігається у файлі, лише визначає розмір для завантажувача.
   
2. **DATA сегмент**: Ініціалізовані глобальні змінні (як у v3) значно збільшують DATA сегмент (4584 байти) та розмір файлу (17792 байт), що підтверджує, що дані зберігаються безпосередньо у виконуваному файлі.

3. **Локальні змінні**: Не впливають на розмір сегментів, оскільки виділяються під час виконання програми у стеку.

4. **Оптимізація**: Прапорець `-O2` незначно змінює text сегмент (1702 vs 1691), але не впливає на data та bss. Прапорець `-g` збільшує розмір файлу (14336 байт), але не змінює розмір сегментів, оскільки налагоджувальна інформація зберігається в окремих секціях.

## 3. Дослідження стеку процесу

### Код програми (`stack_analyzer.c`):
```c
#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>

#define MSG "In function %20s; &localvar = %p\n"

static void deepest() {
    int localvar = 5;
    printf(MSG, __FUNCTION__, &localvar);
    printf("PID: %d\n", getpid());
    pause();
}

static void middle() {
    int localvar = 5;
    printf(MSG, __FUNCTION__, &localvar);
    deepest();
}

static void outer() {
    int localvar = 5;
    printf(MSG, __FUNCTION__, &localvar);
    middle();
}

int main() {
    int localvar = 5;
    printf(MSG, __FUNCTION__, &localvar);
    outer();
    return 0;
}
```

### Результати виконання:
```
In function                 main; &localvar = 0x820aec5ac
In function                outer; &localvar = 0x820aec58c
In function               middle; &localvar = 0x820aec56c
In function              deepest; &localvar = 0x820aec54c
PID: 1540
```

### Аналіз за допомогою pstack:
```
1540: /usr/home/dima/aspz2/stack_analyzer
----------------- thread -1 (running) -----------------
 0x822c0ca6a __sys_sigsuspend (4008d7, 0, dc77ae39, 1544c786, 20aec628, 5) + a
    0x4008d7 deepest (40090e, 0, dc77ae39, 1544c786, 20aec628, 5) + 45
    0x40090e middle (400945, 0, dc77ae39, 1544c786, 20aec628, 5) + 34
    0x400945 outer (40097c, 0, dc77ae39, 1544c786, 20aec628, 5) + 34
    0x40097c main (4006a0, 0, 4005a0, 0, 0, 0) + 34
    0x4006a0 _start (218c0008, 8, 0, 0, 0, 0) + 100
```

### Аналіз за допомогою GDB:
```
(gdb) bt
#0  0x0000000822c0ca6a in _sigsuspend () from /lib/libc.so.7
#1  0x0000000822b83a75 in pause () from /lib/libc.so.7
#2  0x00000000004008d7 in deepest () at stack_analyzer.c:11
#3  0x000000000040090e in middle () at stack_analyzer.c:17
#4  0x0000000000400945 in outer () at stack_analyzer.c:23
#5  0x000000000040097c in main () at stack_analyzer.c:29
```

### Ключові спостереження:
1. Адреси локальних змінних зменшуються при поглибленні у стек:
   - main: 0x820aec5ac
   - outer: 0x820aec58c (різниця 32 байти)
   - middle: 0x820aec56c (різниця 32 байти)
   - deepest: 0x820aec54c (різниця 32 байти)

2. Стек викликів відображає послідовність виконання:
   - main -> outer -> middle -> deepest -> pause()

3. Інструменти pstack та GDB показують ідентичну структуру викликів, але pstack надає більш стислий вивід.

## 4. Додаткова демонстрація: BSS сегмент

### Код програми (`bss_test.c`):
```c
#include <stdio.h>
char large_array[1024*1024*10]; // 10 MB у BSS

int main() {
    printf("Програма з великим BSS сегментом\n");
    return 0;
}
```

### Результати:
```
Розмір файлу: 13824 байт
Сегменти:
  text   data        bss        dec        hex   filename
  1742    568   10485792   10488102   0xa00926   bss_test
```

**Висновок:**  
Незважаючи на величезний BSS сегмент (10 MB), розмір виконуваного файлу залишився малим (13.8 KB). Це підтверджує, що BSS не зберігається у виконуваному файлі, а лише визначає розмір пам'яті, яку потрібно виділити під час завантаження програми.

## Загальні висновки

1. **Архітектурні відмінності**: Розмір типів даних (як time_t) критично залежить від архітектури, що впливає на поведінку програми у довгостроковій перспективі.

2. **Сегменти пам'яті**:
   - **TEXT**: Містить виконуваний код. Чутливий до оптимізації.
   - **DATA**: Містить ініціалізовані глобальні змінні. Збільшує розмір файлу.
   - **BSS**: Містить неініціалізовані глобальні змінні. Не впливає на розмір файлу.
   - **Локальні змінні**: Виділяються у стеку під час виконання.

3. **Стек процесу**:
   - Організований у вигляді LIFO (Last-In-First-Out)
   - Кожен виклик функції створює новий кадр стеку
   - Адреси локальних змінних зменшуються при поглибленні у стек
   - Інструменти pstack та GDB дозволяють аналізувати стек викликів

4. **Оптимізація**:
   - `-O2` незначно зменшує розмір text сегменту
   - `-g` збільшує розмір файлу через додаткову налагоджувальну інформацію
   - Розмір файлу не корелює з розміром BSS сегменту
